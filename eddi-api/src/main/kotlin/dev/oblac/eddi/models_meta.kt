package dev.oblac.eddi

import kotlin.reflect.KClass

object Events {
    private val klassToMeta = mutableMapOf<KClass<out Event>, EventMeta<out Event>>()
    private val nameToMeta = mutableMapOf<EventName, EventMeta<out Event>>()
    private val klassToName = mutableMapOf<KClass<out TTag<Event>>, EventName>()

    fun register(events: List<EventMeta<out Event>>) {
        events.forEach {
            klassToMeta[it.CLASS] = it
            nameToMeta[it.NAME] = it
        }
    }

    fun register(klass: KClass<out TTag<Event>>, eventName: EventName) {
        klassToName[klass] = eventName
    }

    @Suppress("UNCHECKED_CAST")
    fun <E : Event> metaOf(event: E): EventMeta<E> =
        klassToMeta[event::class] as? EventMeta<E> ?: error("Event ${event::class.simpleName} is not registered")

    fun metaOf(name: EventName): EventMeta<out Event> =
        nameToMeta[name] ?: error("Event with name '${name.value}' is not registered")

    fun refOf(tag: TTag<Event>): Ref {
        val name = klassToName[tag::class] ?: error("Tag ${tag::class.simpleName} is not registered")
        return Ref(name, tag.seq)
    }
}

/**
 * Each [Event] will have its own [EventMeta] implementation generated by KSP.
 */
interface EventMeta<E: Event> {
    val CLASS: KClass<out Event>
    val NAME: EventName
    fun refs(event: E): Array<Ref>
}
