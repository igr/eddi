package dev.oblac.eddi.ksp

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.validate
import java.io.BufferedWriter

/**
 * KSP processor that generates Event classes.
 */
class EventProcessor(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger,
    private val env: SymbolProcessorEnvironment
) : SymbolProcessor {

    companion object Companion {
        private const val EVENT_INTERFACE_NAME = "dev.oblac.eddi.Event"
        private const val TAG_INTERFACE_NAME = "dev.oblac.eddi.Tag"
    }

    private val processedEventClasses = mutableSetOf<String>()
    private var processed = false

    override fun process(resolver: Resolver): List<KSAnnotated> {
        if (processed) {
            return emptyList()
        }
        val eventInterface = resolver.getClassDeclarationByName(
            resolver.getKSNameFromString(EVENT_INTERFACE_NAME)
        )

        if (eventInterface == null) {
            logger.warn("Event interface not found: $EVENT_INTERFACE_NAME")
            return emptyList()
        }

        val eventImplementations = resolver.getNewFiles()
            .flatMap { it.declarations }
            .filterIsInstance<KSClassDeclaration>()
            .filter { classDeclaration ->
                classDeclaration.superTypes.any { superType ->
                    val resolvedType = superType.resolve()
                    val declaration = resolvedType.declaration
                    declaration.qualifiedName?.asString() == EVENT_INTERFACE_NAME
                }
            }
            .filter { it.validate() }
            .toList()

        eventImplementations.forEach { tagClass ->
            logger.info("Processing event class: ${tagClass.qualifiedName?.asString()}")
            val qualifiedName = tagClass.qualifiedName?.asString() ?: return@forEach
            if (qualifiedName !in processedEventClasses) {
                processedEventClasses.add(qualifiedName)
                generateEventCode(tagClass)
            }
        }

        return emptyList()
    }

    override fun finish() {
        if (processedEventClasses.isNotEmpty()) {
            generateEventRegistry(processedEventClasses)
        }
    }

    private fun generateEventRegistry(processedEventClasses: Set<String>) {
        val file = env.codeGenerator.createNewFile(
            dependencies = Dependencies(aggregating = true),
            packageName = "dev.oblac.eddi.meta",
            fileName = "EventsRegistry"
        )

        file.write(
            """
            package dev.oblac.eddi.meta

            object EventsRegistry {
                val items = listOf(${processedEventClasses.map{it + "Event"}.joinToString { it }})
            }
            """.trimIndent().toByteArray()
        )
    }

    private fun generateEventCode(eventClass: KSClassDeclaration) {
        val packageName = eventClass.packageName.asString()
        val className = eventClass.simpleName.asString()
        val targetClassName = "${className}Event"

        val tagPropertiesOfEvent = tagPropertiesOfRecord(eventClass)

        val containingFile = eventClass.containingFile
        val dependencies = if (containingFile != null) {
            Dependencies(true, containingFile)
        } else {
            Dependencies(true)
        }

        val file = codeGenerator.createNewFile(
            dependencies = dependencies,
            packageName = packageName,
            fileName = targetClassName
        )

        file.bufferedWriter().use { writer ->
            writeSourceFile(writer, packageName, className, targetClassName, tagPropertiesOfEvent)
        }

        logger.info("Generated $packageName.$targetClassName for $className")
    }

    private fun writeSourceFile(
        writer: BufferedWriter,
        packageName: String,
        className: String,
        targetClassName: String,
        tagPropertiesOfEvent: List<String>
    ) {
        val tagNames = tagPropertiesOfEvent.joinToString(", ") { "event.$it" }

        writer.write(
            """
                |package $packageName
                |
                |import dev.oblac.eddi.EventName
                |
                |/**
                | * Generated companion class for [$className].
                | * This is a marker class generated by TagFooProcessor.
                | */
                |object $targetClassName: dev.oblac.eddi.EventMeta<$className> {
                |    
                |    override val CLASS = $className::class
                |    override val NAME = EventName.of(CLASS)
                |    
                |    override fun refs(event: $className): Array<dev.oblac.eddi.Tag> =
                |        arrayOf($tagNames)
                |}
            """.trimMargin()
        )
    }

    /**
     * Filters the properties of the event record that implement the Tag interface.
     */
    private fun tagPropertiesOfRecord(eventClass: KSClassDeclaration): List<String> =
        (eventClass.primaryConstructor?.parameters
            ?.filter { param ->
                val paramType = param.type.resolve()
                val declaration = paramType.declaration
                declaration.qualifiedName?.asString() == TAG_INTERFACE_NAME ||
                        (declaration as? KSClassDeclaration)?.superTypes?.any { superType ->
                            superType.resolve().declaration.qualifiedName?.asString() == "dev.oblac.eddi.Tag"
                        } == true
            }
            ?.mapNotNull { it.name?.asString() }
            ?: emptyList())
}
